---
title: "Time Series CV"
author: "Tiago Souza"
date: "1/31/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(tidymodels)
library(lubridate)

library(httr)
library(timetk)
```

## Step 0: Parameters
```{r}
# Number of periods to forecast
forecast_length <- 20 
# Year that ends training data
year_limit_train <- 2018 
# Initial number of periods included in a split
initial_periods <- 36
# Maximum number of lags
lag_max <- 12
# Number of splits in output
splits_number <- 20

```


## Step 1: Download and tidy data

In this example we will use Manufacturing production data from Brazil.

Notice below that codes appear as variable names, the first row of the data frame contains information about the variables (not data itself), and all variables are character.

```{r}

data_links <- list(
  manufacturing = "https://apisidra.ibge.gov.br/values/t/3653/v/3134/c544/129316/p/all/n1/all",
  retail = "https://apisidra.ibge.gov.br/values/t/3417/v/1186/c11046/40312/p/all/n1/all",
  services = "https://apisidra.ibge.gov.br/values/t/6442/v/8677/c11046/40312/p/all/n1/all")

download_data <- function(url) {
  data <- GET(url = url) %>% 
    content(as = "parsed") %>% 
    map_dfr(., ~.)
}

data <- map_dfr(data_links, download_data, .id = "variable") %>% 
  
  filter(NC == "1") %>% 
  
  transmute(
    variable = variable,
    date = ymd(paste0(D3C,"01")),
    value = as.numeric(V)
  )

print(data)
```

## Step 2: Define models

Here we define a set of models and the names of their respective recipes. What defines one specification is a pair model-recipe. 

```{r def_models}
source("basic_workflows.R")

models_def <- tribble(
  ~model_id, ~recipe_id,
  "workflow_lm", "recipe_basic",
  "workflow_lm", "recipe_lag",
  "workflow_xgb", "recipe_basic",
  "workflow_xgb", "recipe_lag",
  "workflow_rf", "recipe_basic",
  "workflow_rf", "recipe_lag",
  "workflow_svm", "recipe_basic",
  "workflow_svm", "recipe_lag",
) %>% 
  
  mutate(model = map(model_id, ~get(.x)))

print(models_def)

```

## Step 3: Split Data - train/test

Now we define train and test samples based on one year and create a data frame to store forecasts.
```{r}
data_complete <- data %>% 
  
  group_nest(variable) %>% 
  
  mutate(
    data_train = map(data, ~ .x %>% filter(year(date) < year_limit_train)),
    data_test = map(data, ~ .x %>% filter(year(date) >= year_limit_train)),
    data_extended = map(data, ~ .x %>% future_frame(
                                        .date_var = date,
                                        .length_out = forecast_length,
                                        .bind_data = TRUE)),
    data_forecast = map(data_extended, ~ .x %>% filter(is.na(value))))

print(data_complete)
```

## Step 4: Split Data - CV

Remember that a recipe is defined by an equation and a data set. Hence, before creating recipes, we must split the training data.
```{r}
data_splits <- data_complete %>% 
  
  transmute(
    variable = variable,
    split = map(data_train, ~ .x %>% time_series_cv(
                                      date_var = date,
                                      initial = initial_periods,
                                      assess = forecast_length,
                                      lag = lag_max,
                                      cumulative = TRUE,
                                      slice_limit = splits_number))) %>% 
  
  unnest(split) %>% 
  
  rename(split_id = id, 
         split = splits)

print(data_splits)
```

## Step 5: Recipes

