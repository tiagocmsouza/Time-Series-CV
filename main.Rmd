
## Step 6: Fitting models to all splits

```{r, models-fit, cache=TRUE}
models_fitted <- models_components %>% 
  
  mutate(fit = map2(workflow, split, ~ fit(.x, data = training(.y)))) %>% 
  
  select(-workflow)

head(models_fitted)
```
## Step 7: Calibrated data for test sample

```{r, data-calibr}
data_calibr <- models_fitted %>% 
  
  mutate(
    fitted_recipe = map(fit, ~ extract_recipe(.x)),
    fitted_model = map(fit, ~ extract_fit_parsnip(.x)),
    data = map(split, ~ testing(.x)),
    data_test = map2(fitted_recipe, data, ~ bake(.x, .y)),
    pred = map2(fitted_model, data_test, ~ predict(.x, new_data = .y %>% select(-value))),
    across(c(data, pred), ~ map(.x, function(x) slice_tail(x, n = forecast_length))),
    data = map2(data, pred, ~ .x %>% bind_cols(.y))
  ) %>% 
  
  select(variable,
         model_id,
         recipe_id,
         split_id,
         data) %>% 
  
  unnest(data)

head(data_calibr)
```
## Step 8: Error metrics

```{r, forecast-errors}
error_metrics <- data_calibr %>% 
  
  group_by(variable, model_id, recipe_id, split_id) %>% 
  
  metrics(value, .pred) %>% 
  
  group_by(variable, model_id, recipe_id, .metric) %>% 
  
  summarize(mean_error = mean(.estimate), .groups = "drop_last")

head(error_metrics)
```

## Step 9: Best model

The metric of choice will be "MAE".

```{r, best-model}
best_model <- error_metrics %>% 
  
  filter(.metric == "mae") %>% 
  
  group_by(variable) %>% 
  
  filter(mean_error == min(mean_error)) %>% 
  
  select(variable, model_id, recipe_id)

head(best_model)
```

## Step 10: Refit best models

```{r, refit-models}
refit_models <- best_model %>% 
  
  left_join(data_complete, by = "variable") %>% 
  
  left_join(models_def, by = c("model_id", "recipe_id")) %>% 
  
  mutate(
    recipe = map2(data_train, recipe_id, ~ create_recipe(.x, .y)),
    workflow = map2(workflow, recipe, ~ .x %>% add_recipe(.y)),
    fit = map2(workflow, data_train, ~ fit(.x, data = .y)),
    fitted_recipe = map(fit, ~ extract_recipe(.x)),
    fitted_model = map(fit, ~ extract_fit_parsnip(.x))
  ) %>% 
  
  ungroup()

head(refit_models)
```

## Step 11: Performance with respect to test data

```{r, performance-test}
data_perf <- refit_models %>% 
  
  select(variable,
         data_test,
         fitted_recipe,
         fitted_model) %>% 
  
  mutate(
    data_test = map2(fitted_recipe, data_test, ~ bake(.x, .y)),
    pred = map2(fitted_model, data_test, ~ predict(.x, new_data = .y %>% select(-value))),
    across(c(data_test, pred), ~ map(.x, function(x) slice_tail(x, n = forecast_length))),
    data_test = map2(data_test, pred, ~ .x %>% select(value) %>%  bind_cols(.y))
  ) %>% 
  
  select(
    variable,
    data_test
  ) %>% 
  
  unnest(data_test)

head(data_perf)
```
```{r, chart-performance}
data_perf %>% 
  
  ggplot(aes(x=value, y=.pred))+
    geom_point()+ 
    geom_smooth(method = "lm", formula = y ~ x)+
    facet_grid(variable ~ .)
```


## Step 11: Forecasts

Now we turn to forecasting the future, and for that we will need a recursive approach. This is needed since to forecast $n$ periods ahead, given the existence of lag variables in the models, it is needed to have the forecast for the $n-1$ previous periods.

```{r, forecasts}
check_forecast <- function(df_refit) {
  
  check <- df_refit %>% 
  
  select(data_forecast) %>% 
  
  transmute(check = map(data_forecast, ~ .x %>% 
                       select(value) %>% 
                       anyNA()),
            check = as.logical(check)) %>% 
  
  use_series(check) %>% 
  
  any()
  
  return(check)
  
}

final <- refit_models

while(check_forecast(final)) {

final <- final %>% 
  
  mutate(
    pred = map2(fitted_recipe, data_extended, ~ bake(.x, .y) %>% slice_tail(n = 1)),
    pred = map(pred, ~ .x %>% filter(is.na(value)) %>% select(-value)),
    pred = map2(fitted_model, pred, ~ predict(.x, new_data = .y)),
    pred = map2(data_forecast, pred, 
                ~ .x %>% filter(is.na(value)) %>% 
                  mutate(value = if_else(date == min(date), 
                                         .y %>% use_series(.pred),
                                         value))),
    data_forecast = map2(data_forecast, pred, ~ .x %>% rows_update(.y, by = "date")),
    data_extended = map2(data_extended, pred, ~ .x %>% rows_update(.y, by = "date"))
    ) 
}
  
final <- final %>% 
  select(variable,
         data,
         data_forecast)

head(final)
```

```{r, chart-forecast}
plot_final <- final %>% 
  
  select(-data_forecast) %>% 
  
  unnest(data) %>% 
  
  mutate(data = "past") %>% 
  
  bind_rows(final %>% 
              select(-data) %>% 
              unnest(data_forecast) %>% 
              mutate(data = "future")) 

plot_final %>% 
  
  ggplot(aes(x = date, y = value, color = data)) +
    geom_line() +
    facet_grid(. ~ variable)
```

