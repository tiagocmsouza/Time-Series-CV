---
title: "Time Series CV"
author: "Tiago Souza"
date: "1/31/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(tidymodels)
library(lubridate)

library(httr)
library(timetk)
```

## Step 0: Parameters
```{r}
# Number of periods to forecast
forecast_length <- 20 
# Year that ends training data
year_limit_train <- 2018 
# Initial number of periods included in a split
initial_periods <- 36
# Maximum number of lags
lag_max <- 12
# Number of splits in output
splits_number <- 20

```


## Step 1: Download and tidy data

In this example we will use Manufacturing production data from Brazil.

Notice below that codes appear as variable names, the first row of the data frame contains information about the variables (not data itself), and all variables are character.

```{r}

data_links <- list(
  manufacturing = "https://apisidra.ibge.gov.br/values/t/3653/v/3134/c544/129316/p/all/n1/all",
  retail = "https://apisidra.ibge.gov.br/values/t/3417/v/1186/c11046/40312/p/all/n1/all")

download_data <- function(url) {
  data <- GET(url = url) %>% 
    content(as = "parsed") %>% 
    map_dfr(., ~.)
}

data <- map_dfr(data_links, download_data, .id = "variable") %>% 
  
  filter(NC == "1") %>% 
  
  transmute(
    variable = variable,
    date = ymd(paste0(D3C,"01")),
    value = as.numeric(V)) %>% 
  
  group_by(variable) %>% 
  
  mutate(value = value / lag(value, n=1)) %>% 
  
  drop_na() %>% 
  
  ungroup()

print(data)

data %>% 
  ggplot(aes(x = date, y = value, color = variable)) + 
  geom_line() + 
  facet_grid(variable ~ .)
```


## Step 2: Define models

Here we define a set of models and the names of their respective recipes. What defines one specification is a pair model-recipe. 

```{r def_models}
source("basic_workflows.R")

models_def <- tribble(
  ~model_id, ~recipe_id,
  "lm", "recipe_primary",
  "xgb", "recipe_primary",
  "rf", "recipe_primary",
  "svm", "recipe_primary",
  "lm", "recipe_lag",
  "xgb", "recipe_lag",
  "rf", "recipe_lag",
  "svm", "recipe_lag"
) %>% 
  
  mutate(workflow = map(model_id, ~get(.x)))

print(models_def)

```

## Step 3: Split Data - train/test

Now we define train and test samples based on one year and create a data frame to store forecasts.
```{r}
data_complete <- data %>% 
  
  group_nest(variable) %>% 
  
  mutate(
    data_train = map(data, ~ .x %>% filter(year(date) < year_limit_train)),
    data_test = map(data, ~ .x %>% filter(year(date) >= year_limit_train)),
    data_extended = map(data, ~ .x %>% future_frame(
                                        .date_var = date,
                                        .length_out = forecast_length,
                                        .bind_data = TRUE)),
    data_forecast = map(data_extended, ~ .x %>% filter(is.na(value)))
    )

print(data_complete)
```

## Step 4: Split Data - CV

Remember that a recipe is defined by an equation and a data set. Hence, before creating recipes, we must split the training data.
```{r}
data_splits <- data_complete %>% 
  
  transmute(
    variable = variable,
    split = map(data_train, ~ .x %>% time_series_cv(
                                      date_var = date,
                                      initial = initial_periods,
                                      assess = forecast_length,
                                      lag = lag_max,
                                      cumulative = TRUE,
                                      slice_limit = splits_number))) %>% 
  
  unnest(split) %>% 
  
  rename(split_id = id, 
         split = splits)

print(data_splits)
```

## Step 5: Recipes

Since a recipe is defined by a model and a data set, we define a function that will receive each component of a recipe and create it.

We create 2 examples of recipes, based on a fixed column name with data ("value") and a fixed specification of lag structure (lag 1 and 12). Notice that the column "date" must be removed from the data in order to run.

```{r}
create_recipe <- function(data, recipe_id) {
  
  data <- tryCatch(training(data), 
                   error = function(e) data)
  
  recipe_primary <- recipe(value ~ ., data = data) %>% 
                      step_mutate(month = as_factor(month(date))) %>% 
                      step_dummy(month, one_hot = FALSE) %>% 
                      step_rm(date)
  
  recipe_lag <- recipe(value ~ ., data = data) %>% 
                      step_mutate(month = as_factor(month(date))) %>% 
                      step_dummy(month, one_hot = FALSE) %>% 
                      step_lag(value, c(1,12)) %>% 
                      step_naomit(all_predictors()) %>% 
                      step_rm(date)
  
  return(get(recipe_id))
  
}
```

## Step 5: Complete tibble with all components

```{r}
models_components <- models_def %>% 
  
  expand_grid(data_splits) %>% 
  
  mutate(
    recipe = map2(split, recipe_id, ~ create_recipe(.x, .y)),
    workflow = map2(workflow, recipe, ~ .x %>% add_recipe(.y))#,
    #fit = map2(workflow, split, ~ fit(.x, data = training(.y)))
    )

print(models_components)
```

  
